package com.kegy.mvps.compiler;

import java.lang.ref.Reference;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.annotation.processing.Processor;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedOptions;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.TypeMirror;

import com.google.auto.service.AutoService;
import com.kegy.mvps.annotation.CanBeNull;
import com.kegy.mvps.annotation.Inject;
import com.kegy.mvps.compiler.base.BaseProcessor;
import com.kegy.mvps.compiler.inject.InjectBuilder;
import com.kegy.mvps.compiler.utils.ElementUtils;
import com.squareup.javapoet.TypeName;

@AutoService(Processor.class)
@SupportedOptions({InjectProcessor.GENERATE_PKG_NAME})
public class InjectProcessor extends BaseProcessor {
  static final String GENERATE_PKG_NAME = "generatePkg";

  private boolean mHasProcessed;

  @Override
  public boolean process(Set<? extends TypeElement> set, RoundEnvironment roundEnvironment) {
    if (mHasProcessed) {
      return false;
    }
    parseInject(roundEnvironment);
    mHasProcessed = true;
    return false;
  }

  private void parseInject(RoundEnvironment roundEnvironment) {
    ElementUtils entries = ElementUtils.fromRoundEnv(roundEnvironment, Inject.class);
    for (Map.Entry<TypeElement, List<Element>> entry : entries) {
      List<Element> fields = entry.getValue();
      if (fields == null) {
        continue;
      }
      generateClass(entry.getKey(), fields);
    }
  }

  private void generateClass(Element root, List<Element> fields) {
    if (root == null || root.getKind() != ElementKind.CLASS) {
      return;
    }
    String pkg = mElementUtils.getPackageOf(root).toString();
    InjectBuilder injectBuilder =
        new InjectBuilder(pkg, root.getSimpleName().toString(), mAutoGenerated, TypeName.get(root.asType()));
    for (Element field : fields) {
      if (field.getKind() != ElementKind.FIELD || field.getModifiers().contains(Modifier.STATIC)) {
        continue;
      }
      Inject inject = field.getAnnotation(Inject.class);
      if (inject == null) {
        continue;
      }
      String key = inject.value();
      String fieldName = field.getSimpleName().toString();
      boolean canBeNull = field.getAnnotation(CanBeNull.class) != null;
      TypeMirror fieldType = mTypeUtils.erasure(field.asType());
      if ("".equals(key)) {
        injectBuilder.onFieldByType(key, fieldName,
            TypeName.get(fieldType), canBeNull, mTypeUtils.isAssignable(fieldType,
                mTypeUtils.erasure(mElementUtils.getTypeElement(Reference.class.getName()).asType())));
      } else {
        injectBuilder.onFieldByName(key, fieldName,
            TypeName.get(fieldType), canBeNull, mTypeUtils.isAssignable(fieldType,
                mTypeUtils.erasure(mElementUtils.getTypeElement(Reference.class.getName()).asType())));
      }
      injectBuilder.onReset(key, fieldName, TypeName.get(fieldType));
    }
    writeClass(injectBuilder.getPkg(), injectBuilder.getCls(), injectBuilder.build());
  }

  @Override
  public Set<String> getSupportedAnnotationTypes() {
    Set<String> set = new HashSet<>();
    set.add(Inject.class.getName());
    return set;
  }

  @Override
  public SourceVersion getSupportedSourceVersion() {
    return SourceVersion.RELEASE_8;
  }
}
